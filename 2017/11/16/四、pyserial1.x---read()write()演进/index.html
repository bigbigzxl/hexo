<!DOCTYPE html>

<html class="theme-next pisces use-motion" lang="zh-Hans">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"
  />
  <meta name="theme-color" content="#222">

  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />

  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"
  />

  <link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet"
                                                                                  type="text/css" />

  <link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">

  <link rel="icon" type="image/png" sizes="32x32" href="/images/32x32.png?v=5.1.3">

  <link rel="icon" type="image/png" sizes="16x16" href="/images/16x16.png?v=5.1.3">

  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">

  <meta name="keywords" content="Hexo, ZXL" />

  <meta name="description" content="摘要：基于最开始的pyserial1.0讲解read/write基本原理，之后就三个阶段（pyserial1.x，pyserial2.x，pyserial3.x）讲解实现方式的演进，本篇围绕pyserial1.0讲解原理并尝试分析pyserial1.x版本期间作者所做的改进措施。    write（）实现机理    放在最开始: 发现一本书，讲python在win32下编程的，叫">
  <meta property="og:type" content="article">
  <meta property="og:title" content="四、pyserial1.x---read()&#x2F;write()演进">
  <meta property="og:url" content="http://www.jianshu.com/u/a08f88f9ed9d/2017/11/16/四、pyserial1.x---read()write()演进/index.html">
  <meta property="og:site_name" content="十曰立">
  <meta property="og:description" content="摘要：基于最开始的pyserial1.0讲解read/write基本原理，之后就三个阶段（pyserial1.x，pyserial2.x，pyserial3.x）讲解实现方式的演进，本篇围绕pyserial1.0讲解原理并尝试分析pyserial1.x版本期间作者所做的改进措施。    write（）实现机理    放在最开始: 发现一本书，讲python在win32下编程的，叫">
  <meta property="og:locale" content="zh-Hans">
  <meta property="og:image" content="https://www.etlhive.com/wp-content/uploads/2016/10/19-PYTHON-The-Most-Popular-Coding-Language.jpg">
  <meta property="og:updated_time" content="2017-12-18T07:18:50.719Z">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="四、pyserial1.x---read()&#x2F;write()演进">
  <meta name="twitter:description" content="摘要：基于最开始的pyserial1.0讲解read/write基本原理，之后就三个阶段（pyserial1.x，pyserial2.x，pyserial3.x）讲解实现方式的演进，本篇围绕pyserial1.0讲解原理并尝试分析pyserial1.x版本期间作者所做的改进措施。    write（）实现机理    放在最开始: 发现一本书，讲python在win32下编程的，叫">
  <meta name="twitter:image" content="https://www.etlhive.com/wp-content/uploads/2016/10/19-PYTHON-The-Most-Popular-Coding-Language.jpg">

  <script type="text/javascript" id="hexo.configurations">
    var NexT = window.NexT || {};
    var CONFIG = {
      root: '/',
      scheme: 'Pisces',
      version: '5.1.3',
      sidebar: {
        "position": "left",
        "display": "post",
        "offset": 12,
        "b2t": false,
        "scrollpercent": false,
        "onmobile": false
      },
      fancybox: true,
      tabs: true,
      motion: {
        "enable": true,
        "async": false,
        "transition": {
          "post_block": "fadeIn",
          "post_header": "slideDownIn",
          "post_body": "slideDownIn",
          "coll_header": "slideLeftIn",
          "sidebar": "slideUpIn"
        }
      },
      duoshuo: {
        userId: '0',
        author: '博主'
      },
      algolia: {
        applicationID: '',
        apiKey: '',
        indexName: '',
        hits: {
          "per_page": 10
        },
        labels: {
          "input_placeholder": "Search for Posts",
          "hits_empty": "We didn't find any results for the search: ${query}",
          "hits_stats": "${hits} results found in ${time} ms"
        }
      }
    };

  </script>

  <link rel="canonical" href="http://www.jianshu.com/u/a08f88f9ed9d/2017/11/16/四、pyserial1.x---read()write()演进/"
  />

  <title>四、pyserial1.x---read()/write()演进 | 十曰立</title>

</head>

<div id="hexo-helper-live2d">
  <canvas id="live2dcanvas" width="150" height="300"></canvas>
</div>
<style>
  #live2dcanvas {
    position: fixed;
    width: 150px;
    height: 300px;
    opacity: 0.7;
    right: 0px;
    z-index: 999;
    pointer-events: none;
    bottom: -20px;
  }

</style>
<script type="text/javascript" src="/live2d/device.min.js"></script>
<script type="text/javascript">
  const loadScript = function loadScript(c, b) {
    var a = document.createElement("script");
    a.type = "text/javascript";
    "undefined" != typeof b && (a.readyState ? a.onreadystatechange =
      function() {
        if ("loaded" == a.readyState || "complete" == a.readyState) a.onreadystatechange =
          null, b()
      } : a.onload = function() {
        b()
      });
    a.src = c;
    document.body.appendChild(a)
  };
  (function() {
    if ((typeof(device) != 'undefined') && (device.mobile())) {
      document.getElementById("live2dcanvas").style.width = '75px';
      document.getElementById("live2dcanvas").style.height = '150px';
    } else
    if (typeof(device) === 'undefined') console.error(
      'Cannot find current-device script.');
    loadScript("/live2d/script.js", function() {
      loadlive2d("live2dcanvas", "/live2d/assets/haruto.model.json", 0.5);
    });
  })();

</script>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
    <a href="https://github.com/bigbigzxl">
      <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/365986a132ccd6a44c23a9169022c0b5c890c387/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f7265645f6161303030302e706e67"
                                                                                      alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png">
    </a>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner">
        <div class="site-brand-wrapper">
          <div class="site-meta custom-logo">

            <div class="custom-logo-site-title">
              <a href="/" class="brand" rel="start">
                <span class="logo-line-before">
                  <i></i>
                </span>
                <span class="site-title">十曰立</span>
                <span class="logo-line-after">
                  <i></i>
                </span>
              </a>
            </div>

            <p class="site-subtitle">每日十立其身</p>

          </div>

          <div class="site-nav-toggle">
            <button>
              <span class="btn-bar"></span>
              <span class="btn-bar"></span>
              <span class="btn-bar"></span>
            </button>
          </div>
        </div>

        <nav class="site-nav">

          <ul id="menu" class="menu">

            <li class="menu-item menu-item-home">
              <a href="/" rel="section">

                <i class="menu-item-icon fa fa-fw fa-home"></i>
                <br /> 首页
              </a>
            </li>

            <li class="menu-item menu-item-categories">
              <a href="/categories/" rel="section">

                <i class="menu-item-icon fa fa-fw fa-heart"></i>
                <br /> 分类
              </a>
            </li>

          </ul>

        </nav>

      </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">

            <div id="posts" class="posts-expand">

              <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">

                <div class="post-block">
                  <link itemprop="mainEntityOfPage" href="http://www.jianshu.com/u/a08f88f9ed9d/2017/11/16/四、pyserial1.x---read()write()演进/">

                  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                    <meta itemprop="name" content="十曰立">
                    <meta itemprop="description" content="">
                    <meta itemprop="image" content="/images/avatar.png">
                  </span>

                  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                    <meta itemprop="name" content="十曰立">
                  </span>

                  <header class="post-header">

                    <h1 class="post-title" itemprop="name headline">四、pyserial1.x---read()/write()演进</h1>

                    <div class="post-meta">
                      <span class="post-time">

                        <span class="post-meta-item-icon">
                          <i class="fa fa-calendar-o"></i>
                        </span>

                        <span class="post-meta-item-text">发表于</span>

                        <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-16T19:21:17+08:00">
                          2017-11-16
                        </time>

                      </span>

                      <span class="post-category">

                        <span class="post-meta-divider">|</span>

                        <span class="post-meta-item-icon">
                          <i class="fa fa-folder-o"></i>
                        </span>

                        <span class="post-meta-item-text">分类于</span>

                        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                          <a href="/categories/python开源库分析/" itemprop="url" rel="index">
                            <span itemprop="name">python开源库分析</span>
                          </a>
                        </span>

                      </span>

                      <div class="post-wordcount">

                        <span class="post-meta-item-icon">
                          <i class="fa fa-file-word-o"></i>
                        </span>

                        <span class="post-meta-item-text">字数统计&#58;</span>

                        <span title="字数统计">
                          4,081
                        </span>

                        <span class="post-meta-divider">|</span>

                        <span class="post-meta-item-icon">
                          <i class="fa fa-clock-o"></i>
                        </span>

                        <span class="post-meta-item-text">阅读时长 &asymp;</span>

                        <span title="阅读时长">
                          20
                        </span>

                      </div>

                    </div>
                  </header>

                  <div class="post-body" itemprop="articleBody">

                    <p>
                      <img src="https://www.etlhive.com/wp-content/uploads/2016/10/19-PYTHON-The-Most-Popular-Coding-Language.jpg"
                                                                                                      alt="">
                    </p>
                    <p>
                      <strong>摘要</strong>：基于最开始的pyserial1.0讲解read/write基本原理，之后就三个阶段（pyserial1.x，pyserial2.x，pyserial3.x）讲解实现方式的演进，本篇围绕pyserial1.0讲解原理并尝试分析pyserial1.x版本期间作者所做的改进措施。</p>
                    <h1 id="write（）实现机理">
                      <a href="#write（）实现机理" class="headerlink" title="write（）实现机理"></a>write（）实现机理</h1>
                    <p>
                      <strong>放在最开始:</strong> 发现一本书，讲python在win32下编程的，叫
                      <a href="https://books.google.com.hk/books?id=fzUCGtyg0MMC&amp;printsec=frontcover&amp;hl=zh-TW#v=onepage&amp;q&amp;f=false"
                                                                                                      target="_blank" rel="external">《Python Programming on Win32》</a>
                    </p>
                    <p>通过
                      <em>notepad++</em>里面的
                      <em>compare</em>插件进行比较各个版本（目前看了
                      <strong>1.0、1.1、1.11、1.13</strong>版本），发现在各版本中
                      <em>write（）</em>函数基本上就没变。</p>
                    <p>代码如下，接下来我们
                      <strong>按行来解析代码</strong>：
                      <br>
                      <figure class="highlight python">
                        <table>
                          <tr>
                            <td class="gutter">
                              <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre>
                            </td>
                            <td class="code">
                              <pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(self, s)</span>:</span></span><br><span class="line"><span class="string">"write string to serial port"</span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> self.hComPort: <span class="keyword">raise</span> portNotOpenError</span><br><span class="line"><span class="comment">#print repr(s),</span></span><br><span class="line">	</span><br><span class="line">overlapped = win32file.OVERLAPPED()</span><br><span class="line">overlapped.hEvent = win32event.CreateEvent(<span class="keyword">None</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">None</span>)</span><br><span class="line">	</span><br><span class="line">win32file.WriteFile(self.hComPort, s, overlapped)</span><br><span class="line"><span class="comment"># Wait for the write to complete.</span></span><br><span class="line">win32event.WaitForSingleObject(overlapped.hEvent, win32event.INFINITE)</span><br><span class="line"><span class="comment">#old: win32file.WriteFile(self.hComPort, s) #, 1,  NULL)</span></span><br></pre>
                            </td>
                          </tr>
                        </table>
                      </figure>
                    </p>
                    <p>
                      <em>self.hcomPort</em>是来自
                      <strong>serialwin32.Serial类初始化</strong>中（注意1.0版本是没有继承
                      <strong>serialutil.FileLike类</strong>的）：
                      <br>
                      <figure class="highlight python">
                        <table>
                          <tr>
                            <td class="gutter">
                              <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre>
                            </td>
                            <td class="code">
                              <pre><span class="line"> self.hComPort = win32file.CreateFile(self.portstr,<span class="comment"># self.portstr = 'COM%d' % (port+1) </span></span><br><span class="line">               win32con.GENERIC_READ | win32con.GENERIC_WRITE,</span><br><span class="line">               <span class="number">0</span>, <span class="comment"># exclusive access</span></span><br><span class="line">               <span class="keyword">None</span>, <span class="comment"># no security</span></span><br><span class="line">               win32con.OPEN_EXISTING,</span><br><span class="line">               win32con.FILE_ATTRIBUTE_NORMAL | win32con.FILE_FLAG_OVERLAPPED,<span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#这里有个疑问：这个函数是怎么将串口映射为一个文件的？</span></span><br><span class="line"><span class="comment">#FileName：The name of the file, pipe, or “other resource” to open.</span></span><br><span class="line"><span class="comment">#这里暂且推断是通过filename来分发、多态实现的。</span></span><br></pre>
                            </td>
                          </tr>
                        </table>
                      </figure>
                    </p>
                    <p>好了，那么
                      <em>win32file.CreateFile()</em>这个函数又是
                      <strong>来自哪儿</strong>呢？</p>
                    <p>这么想吧：我们不是最终要控制串口硬件嘛，但是呐，python是一个寄居在windows操作系统上的一个软体而已，而我们的串口是一个独立的硬件载体，就是天仙跟牛郎的关系嘛，两者之间相互独立，硬是要通信的话，怎么办?孔雀搭桥嘛！windows系统在其中就承担了搭桥的角色，作为一个中间件，信息传递层。</p>
                    <p>好了，我们知道串口硬件在windows下有对应的底层驱动程序（linux同样如此），因此windows直接系统编程可以很方便的控制串口，但是我们的python这仙女呢，是
                      <strong>基于</strong>操作系统用c语言写的一个抽象的软体，没有自己的底层基础，即“飞的起来”这个意识形态上层建筑全靠操作系统一整套的底层基础来支撑；</p>
                    <p>
                      <code>这就好比你在别人的地盘上谋生，同时你又需要利用一些别人的“矿产资源”，你不通过他们的官方渠道来获取，而是选择自己建立一全套采矿产业链，这行的通吗？**首先**你精力、资源、时间够建立这套产业链吗？**其次**人家会允许你在他家门口抽取资源野蛮发展吗？</code>
                    </p>
                    <p>因此，于效率于规范我们都得通过windows的一些统一API接口来控制串口硬件，
                      <strong>那这些统一API怎么调用呢？</strong>
                    </p>
                    <p>他山之石可以攻玉，我们可以借鉴一下windows自己是怎么做的！比如windows下的.net框架是将底层系统API封装成抽象程度更高的API，于是我们编写C#代码的时候用起来就很简单了！捋一下：C#是“仙女1号”，python是“仙女7号”，仙女1号要控制硬件可以直接去调用系统级API，但是这样太繁琐了，会导致很大的代码量，就跟你用汇编写单片机代码一样，于是.net将通用的整理成一个标准框架，以供天下豪杰使用！bingo~那我们也可以给仙女7号也整个中间层框架啊！好的，这部分工作已经有人给做了！</p>
                    <p>
                      <strong>就是pywin32</strong>（
                      <a href="https://pypi.python.org/pypi/pywin32" target="_blank" rel="external">链接在这</a>）：官方描述就是
                      <code>Python extensions for Windows</code>，即对windows的一个python拓展包，已收录在python的官方扩展库里面了。
                      <br>下载下来是一个exe文件，安装后python就可以直接调用它里面的库文件里面的API来进行windows系统编程了！嗯，我们理解到这一层就行了！再往下挖的话就到了windows编程、驱动的范畴了，我们关注于API的使用即可，点到即止。</p>
                    <p>好了，回到之前的问题，
                      <em>win32file.CreateFile()</em>里面的win32file就是pywin32安装后的其中一个库文件里的API，
                      <a href="http://docs.activestate.com/activepython/2.5/pywin32/win32file__CreateFile_meth.html"
                                                                                                      target="_blank" rel="external">(官网docs文件在这)</a>。</p>
                    <h2 id="1-1-win32file-CreateFile">
                      <a href="#1-1-win32file-CreateFile" class="headerlink" title="1.1 win32file.CreateFile()"></a>1.1 win32file.CreateFile()</h2>
                    <figure class="highlight python">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line">win32file.CreateFile</span><br><span class="line">PyHANDLE = CreateFile(fileName,desiredAccess,shareMode,attributes,CreationDisposition,flagsAndAttributes,hTemplateFile)</span><br><span class="line">//Creates <span class="keyword">or</span> opens the a file <span class="keyword">or</span> other object <span class="keyword">and</span> returns a handle that can be used to access the object.</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>
                    <p>从代码可知是创建或者打开一个文件或者对象，并返回一个指针。</p>
                    <p>
                      <strong>这是实际调用：</strong>
                      <br>
                      <figure class="highlight python">
                        <table>
                          <tr>
                            <td class="gutter">
                              <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
                            </td>
                            <td class="code">
                              <pre><span class="line">self.hComPort = win32file.CreateFile(self.portstr,<span class="comment"># self.portstr = 'COM%d' % (port+1) </span></span><br><span class="line">              win32con.GENERIC_READ | win32con.GENERIC_WRITE,</span><br><span class="line">              <span class="number">0</span>, <span class="comment"># exclusive access</span></span><br><span class="line">              <span class="keyword">None</span>, <span class="comment"># no security</span></span><br><span class="line">              win32con.OPEN_EXISTING,</span><br><span class="line">              win32con.FILE_ATTRIBUTE_NORMAL | win32con.FILE_FLAG_OVERLAPPED,<span class="keyword">None</span>)</span><br></pre>
                            </td>
                          </tr>
                        </table>
                      </figure>
                    </p>
                    <p>
                      <strong>这是API参数描述：</strong>
                      <br>
                      <figure class="highlight python">
                        <table>
                          <tr>
                            <td class="gutter">
                              <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
                            </td>
                            <td class="code">
                              <pre><span class="line">fileName : PyUnicode <span class="comment">#The name of the file</span></span><br><span class="line">desiredAccess : int <span class="comment">#access (read-write) mode Specifies the type of access to the object. An application can obtain read access, write access, read-write access, or device query access. This parameter can be any combination of the following values.</span></span><br><span class="line">shareMode : int <span class="comment">#Set of bit flags that specifies how the object can be shared. If dwShareMode is 0, the object cannot be shared. Subsequent open operations on the object will fail, until the handle is closed. To share the object, use a combination of one or more of the following values:</span></span><br><span class="line">attributes : PySECURITY_ATTRIBUTES <span class="comment">#The security attributes, or None</span></span><br><span class="line">CreationDisposition : int   <span class="comment"># Specifies which action to take on files that exist, and which action to take when files do not exist. For more information about this parameter, see the Remarks section. This parameter must be one of the following values:</span></span><br><span class="line">flagsAndAttributes : int  <span class="comment">#file attributes</span></span><br><span class="line">hTemplateFile: PyHANDLE  <span class="comment">#Specifies a handle with GENERIC_READ access to a template file. The template file supplies file attributes and extended attributes for the file being created. Under Win95, this must be 0, else an exception will be raised.</span></span><br></pre>
                            </td>
                          </tr>
                        </table>
                      </figure>
                    </p>
                    <figure class="highlight plain">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line">The following objects can be opened:</span><br><span class="line">files</span><br><span class="line">pipes</span><br><span class="line">mailslots</span><br><span class="line">communications resources</span><br><span class="line">disk devices (Windows NT only)</span><br><span class="line">consoles\directories (open only)</span><br><span class="line">*问题：串口属于哪个类型？*</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>
                    <p>也即：</p>
                    <p>
                      <code>self.portstr = &#39;COM%d&#39; % (port+1)</code>:文件名就是串口号
                      <br>
                      <code>win32con.GENERIC_READ | win32con.GENERIC_WRITE</code>:打开串口对象的读写权限（win32con里面是全部的常量）
                      <br>
                      <code>0, # exclusive access</code>:关闭共享模式，假如对串口进行连续打开操作将会fail
                      <br>
                      <code>None, # no security</code>:如描述，非安全模式。
                      <br>
                      <code>win32con.OPEN_EXISTING,</code>当文件在或者不存在的时候进行的操作，文件不存在时，打开失败。
                      <br>ps.在他们的讨论区说了，为什么在对设备使用createfile（）函数时要使用OPEN_EXISTING标志位。</p>
                    <p>
                      <code>win32con.FILE_ATTRIBUTE_NORMAL | win32con.FILE_FLAG_OVERLAPPED</code>：创建的文件属性，
                      <br>
                      <code>None</code>不使用属性模版</p>
                    <h2 id="1-2-win32file-OVERLAPPED">
                      <a href="#1-2-win32file-OVERLAPPED" class="headerlink" title="1.2 win32file.OVERLAPPED()"></a>1.2 win32file.OVERLAPPED()</h2>
                    <p>关于
                      <code>win32con.FILE_FLAG_OVERLAPPED</code>上一篇已有相关探寻：
                      <br>
                      <code>win32file.OVERLAPPED()：Overlapped I/O是win32的一项技术，你可以要求操作系统为你传送数据，并且在传送完毕时通知你。这项技术使你的程序在I/O进行中仍然能够继续处理事物。Overlapped
                        I/O的基本形式是以ReadFile和WriteFile函数完成的。
                      </code>
                    </p>
                    <p>
                      <strong>小结：异步文件处理机制，用来提高并发及其他性能的。</strong>
                    </p>
                    <h2 id="1-3-win32event-CreateEvent">
                      <a href="#1-3-win32event-CreateEvent" class="headerlink" title="1.3 win32event.CreateEvent()"></a>1.3 win32event.CreateEvent()</h2>
                    <p>
                      <code>win32event.CreateEvent(None, 0, 0, None)</code>:
                      <br>Creates or opens a named or unnamed event object.
                      <br>The
                      <strong>result</strong> is a PyHANDLE object referencing the requested
                      object.
                      <br>
                      <strong>小结：也就是创建一个事件，这个时间可以跟对象挂钩。</strong>
                    </p>
                    <p>至此基本可以完整分析作者写write函数的思路了：
                      <br>
                      <figure class="highlight python">
                        <table>
                          <tr>
                            <td class="gutter">
                              <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre>
                            </td>
                            <td class="code">
                              <pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(self, s)</span>:</span></span><br><span class="line">   <span class="string">"write string to serial port"</span></span><br><span class="line">   <span class="keyword">if</span> <span class="keyword">not</span> self.hComPort: <span class="keyword">raise</span> portNotOpenError</span><br><span class="line">   <span class="comment">#print repr(s),</span></span><br><span class="line">   overlapped = win32file.OVERLAPPED()</span><br><span class="line">   overlapped.hEvent = win32event.CreateEvent(<span class="keyword">None</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">None</span>)</span><br><span class="line">   win32file.WriteFile(self.hComPort, s, overlapped)</span><br><span class="line">   <span class="comment"># Wait for the write to complete.</span></span><br><span class="line">   win32event.WaitForSingleObject(overlapped.hEvent, win32event.INFINITE)</span><br><span class="line">   <span class="comment">#old: win32file.WriteFile(self.hComPort, s) #, 1,  NULL)</span></span><br></pre>
                            </td>
                          </tr>
                        </table>
                      </figure>
                    </p>
                    <p>
                      <strong>
                        <em>首先检测self.hComPort（文件指针）是否存在，假如不存在说明文件创建失败了，就raise一个异常；
                          <br>然后为了提高文件操作性能（毕竟是底层I/O处理啊！），这里开一个异步I/O: overlapped；
                          <br>创建一个不带名字的事件，并将其注册给异步I/O的的事件部分（应该是windows常规代码流程）；
                          <br>然后就以overlapped方式将s字符串写到self.hComPort指向的文件中去，并立马返回（异步处理的核心）。
                          <br>然后事件处理器将等待overlapped.hEvent对象被触发，并且是无限等,也就是死等（有误，见下面分析）到文件被写完。</em>
                      </strong>
                    </p>
                    <p>
                      <strong>这里一个问题：假如我在程序里死等，那么跟同步就没区别了啊！？</strong>
                      <br>
                      <figure class="highlight python">
                        <table>
                          <tr>
                            <td class="gutter">
                              <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
                            </td>
                            <td class="code">
                              <pre><span class="line">WaitForSingleObject()</span><br><span class="line">As the name implies, this function allows you to wait <span class="keyword">for</span> a single object to become signaled.</span><br><span class="line"> It takes two parameters: the handle to the object you wish to wait <span class="keyword">for</span>, <span class="keyword">and</span> a timeout <span class="keyword">in</span> milliseconds</span><br><span class="line"> (<span class="keyword">or</span> win32event.INFINITE <span class="keyword">for</span> no timeout). </span><br><span class="line">The <span class="keyword">return</span> value <span class="keyword">from</span> the function <span class="keyword">is</span> win32event.WAIT_OBJECT_0 <span class="keyword">if</span> the object becomes signaled, </span><br><span class="line">win32event.WAIT_TIMEOUT <span class="keyword">if</span> the timeout interval expired, <span class="keyword">or</span> win32event.WAIT_ABANDONED <span class="keyword">in</span> certain situations</span><br><span class="line"> <span class="keyword">for</span> mutexes (see the Win32 documentation).</span><br></pre>
                            </td>
                          </tr>
                        </table>
                      </figure>
                    </p>
                    <p>
                      <strong>这里也并没有讲清楚！</strong>
                      <br>还好在微软的官网
                      <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms687032(v=vs.85"
                                                                                                      target="_blank" rel="external">(网址在这)</a>.aspx)找到了下面的描述：
                      <br>注意the calling thread，既然是线程那么进入等待状态就是休眠挂起咯~这就是真的异步了啊！让出了CPU！
                      <br>
                      <figure class="highlight python">
                        <table>
                          <tr>
                            <td class="gutter">
                              <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre>
                            </td>
                            <td class="code">
                              <pre><span class="line">Remarks</span><br><span class="line">The WaitForSingleObject function checks the current state of the specified object.</span><br><span class="line"> If the object<span class="string">'s state is nonsignaled, |||the calling thread |||enters the wait state until the object is signaled or</span></span><br><span class="line"><span class="string"> the time-out interval elapses.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">The function modifies the state of some types of synchronization objects. </span></span><br><span class="line"><span class="string">Modification occurs only for the object whose signaled state caused the function to return. </span></span><br><span class="line"><span class="string">For example, the count of a semaphore object is decreased by one.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">The WaitForSingleObject function can wait for the following objects:</span></span><br><span class="line"><span class="string">    Change notification</span></span><br><span class="line"><span class="string">    Console input</span></span><br><span class="line"><span class="string">    Event</span></span><br><span class="line"><span class="string">    Memory resource notification</span></span><br><span class="line"><span class="string">    Mutex</span></span><br><span class="line"><span class="string">    Process</span></span><br><span class="line"><span class="string">    Semaphore</span></span><br><span class="line"><span class="string">    Thread</span></span><br><span class="line"><span class="string">    Waitable timer</span></span><br></pre>
                            </td>
                          </tr>
                        </table>
                      </figure>
                    </p>
                    <h1 id="read-实现原理剖析">
                      <a href="#read-实现原理剖析" class="headerlink" title="read() 实现原理剖析"></a>read() 实现原理剖析</h1>
                    <p>
                      <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/bb540534(v=vs.85"
                                                                                                      target="_blank" rel="external">read() 官方sample</a>.aspx)
                      <br>
                      <figure class="highlight python">
                        <table>
                          <tr>
                            <td class="gutter">
                              <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre>
                            </td>
                            <td class="code">
                              <pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(self, size=<span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="string">"read num bytes from serial port"</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.hComPort: <span class="keyword">raise</span> portNotOpenError</span><br><span class="line">    read = <span class="string">''</span></span><br><span class="line">    <span class="keyword">if</span> size &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">while</span> len(read) &lt; size:</span><br><span class="line">            flags, comstat = win32file.ClearCommError( self.hComPort )</span><br><span class="line">            rc, buf = win32file.ReadFile(self.hComPort, size-len(read), self.overlapped)</span><br><span class="line">            <span class="keyword">if</span> self.timeout:</span><br><span class="line">                rc = win32event.WaitForSingleObject(self.overlapped.hEvent, self.timeout*<span class="number">1000</span>)</span><br><span class="line">                <span class="keyword">if</span> rc == win32event.WAIT_TIMEOUT: <span class="keyword">break</span></span><br><span class="line">                <span class="comment">#<span class="doctag">TODO:</span> if reading more than 1 byte data can be lost when a timeout occours!!!!</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                win32event.WaitForSingleObject(self.overlapped.hEvent, win32event.INFINITE)</span><br><span class="line">            read = read + str(buf)</span><br><span class="line">    <span class="comment">#print "read %r" % str(read)</span></span><br><span class="line">    <span class="keyword">return</span> str(read)</span><br></pre>
                            </td>
                          </tr>
                        </table>
                      </figure>
                    </p>
                    <p>
                      <strong>win32file.ClearCommError( self.hComPort ):</strong>
                    </p>
                    <figure class="highlight plain">
                      <figcaption>
                        <span>information about a communications error and reports the
                          current status of a communications device. The function
                          is called when a communications error occurs, and it clears
                          the device's error flag to enable additional input and
                          output (I/O) operations.```</span>
                      </figcaption>
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line"></span><br><span class="line">总结上面这段话的意思就是，你给我个设备，我来检索设备的通信异常并且报告设备的当前状态。在检索到异常的时候这个函数就会被调用，用来清楚异常标志位好使得“不堵车”，也就是说这个函数就是一名“交警”。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**注意：这两个是在初始化的时候就创建了的，也就是说read是直接使用它的！而在write里面使用的本地变量，重新生成了事件，为何这般处理？也许后续代码跟进的时候会有不同理解吧！留后解决。** `（在pyserial1.6里面就把read函数里面的self.overlapped，直接本地化了，初始化里面定义那两行去掉了，也即这是当时设计的一个小缺陷@2017.8.8）`</span><br><span class="line">```python</span><br><span class="line">__init__():</span><br><span class="line">self.overlapped = win32file.OVERLAPPED()</span><br><span class="line">self.overlapped.hEvent = win32event.CreateEvent(None, 0, 0, None)</span><br><span class="line"></span><br><span class="line">write():</span><br><span class="line">overlapped = win32file.OVERLAPPED()</span><br><span class="line">overlapped.hEvent = win32event.CreateEvent(None, 0, 0, None)</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>
                    <p>
                      <code>今天先写到这，后续的慢慢跟进代码继续分析。2017.08.07@AW</code>
                    </p>
                    <p>
                      <strong>win32file.ReadFile(self.hComPort, size-len(read), self.overlapped)
                        <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa365467(v=vs.85"
                                                                                                        target="_blank" rel="external">
                          (详细链接在这)</a>.aspx)</strong>
                      <br>
                      <figure class="highlight python">
                        <table>
                          <tr>
                            <td class="gutter">
                              <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
                            </td>
                            <td class="code">
                              <pre><span class="line">BOOL WINAPI ReadFile(</span><br><span class="line">  _In_        HANDLE       hFile,</span><br><span class="line">  _Out_       LPVOID       lpBuffer,</span><br><span class="line">  _In_        DWORD        nNumberOfBytesToRead,</span><br><span class="line">  _Out_opt_   LPDWORD      lpNumberOfBytesRead,</span><br><span class="line">  _Inout_opt_ LPOVERLAPPED lpOverlapped</span><br><span class="line">);</span><br></pre>
                            </td>
                          </tr>
                        </table>
                      </figure>
                    </p>
                    <p>
                      <strong>hFile [in]</strong>
                      <br>
                      <code>A handle to the device (for example, a file, file stream, physical
                        disk, volume, console buffer, tape drive, socket, communications
                        resource, mailslot, or pipe).</code>
                    </p>
                    <p>
                      <strong>lpBuffer [out]</strong>
                      <br>
                      <code>A pointer to the buffer that receives the data read from a
                        file or device. This buffer must remain valid for the duration
                        of the read operation. The caller must not use this buffer
                        until the read operation is completed.</code>
                    </p>
                    <p>
                      <strong>nNumberOfBytesToRead [in]</strong>
                      <br>
                      <code>The maximum number of bytes to be read.</code>
                    </p>
                    <p>
                      <strong>lpNumberOfBytesRead [out, optional]</strong>
                      <br>
                      <code>A pointer to the variable that receives the number of bytes
                        read when using a synchronous hFile parameter. ReadFile sets
                        this value to zero before doing any work or error checking.
                        Use NULL for this parameter if this is an asynchronous operation
                        to avoid potentially erroneous results. This parameter can
                        be NULL only when the lpOverlapped parameter is not NULL.
                        For more information, see the Remarks section.</code>
                    </p>
                    <p>
                      <strong>lpOverlapped [in, out, optional]</strong>
                      <br>
                      <code>A pointer to an *OVERLAPPED* structure is required if the *hFile*
                        parameter was opened with *FILE_FLAG_OVERLAPPED*, otherwise
                        it can be *NULL*.</code>
                    </p>
                    <p>
                      <strong>Return value</strong>
                      <br>
                      <code>If the function succeeds, the return value is nonzero (**TRUE**).
                        If the function fails, or is completing asynchronously, the
                        return value is zero (**FALSE**). To get extended error information,
                        call the **GetLastError** function. **Note** The **GetLastError**
                        code **ERROR_IO_PENDING** is not a failure; it designates
                        the read operation is pending completion asynchronously.
                        For more information, see Remarks.</code>
                    </p>
                    <p>
                      <strong>remark</strong>
                      <br>
                      <code>When reading from a communications device, the behavior of
                        *ReadFile is* determined by the current communication time-out
                        as set and retrieved by using the *SetCommTimeouts* and *GetCommTimeouts*
                        functions. Unpredictable results can occur if you fail to
                        set the time-out values. For more information about communication
                        time-outs, see *COMMTIMEOUTS*.</code>
                    </p>
                    <p>
                      <strong>Considerations for working with asynchronous file handles:</strong>
                      <br>
                      <code>**ReadFile** may return before the read operation is complete.
                        In this scenario, **ReadFile** returns **FALSE** and the
                        **GetLastError** function returns **ERROR_IO_PENDING**, which
                        allows the calling process to continue while the system completes
                        the read operation. The *lpOverlapped* parameter must not
                        be **NULL** and should be used with the following facts in
                        mind:Although the event specified in the **OVERLAPPED** structure
                        is set and reset automatically by the system, the offset
                        that is specified in the **OVERLAPPED** structure is not
                        automatically updated. **ReadFile** resets the event to a
                        nonsignaled state when it begins the I/O operation. The event
                        specified in the **OVERLAPPED** structure is set to a signaled
                        state when the read operation is complete; until that time,
                        the read operation is considered pending. Because the read
                        operation starts at the offset that is specified in the **OVERLAPPED**
                        structure, and **ReadFile** may return before the system-level
                        read operation is complete (read pending), neither the offset
                        nor any other part of the structure should be modified, freed,
                        or reused by the application until the event is signaled
                        (that is, the read completes). If end-of-file (EOF) is detected
                        during asynchronous operations, the call to **GetOverlappedResult**
                        for that operation returns **FALSE** and **GetLastError**
                        returns **ERROR_HANDLE_EOF**.</code>
                      <br>
                      <strong>上小段总结</strong>就是：异步文件读写的时候，I/O操作可以挂起等待，主进程能够继续运行，当完成的时候就会触发事件来处理（触发事件、文件读写的相关操作都定义在OVERLAPPED这个结构体里面了）</p>
                    <h2 id="pyserial1-1-read（）">
                      <a href="#pyserial1-1-read（）" class="headerlink" title="pyserial1.1    @read（）"></a>pyserial1.1 @read（）</h2>
                    <figure class="highlight python">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(self, size=<span class="number">1</span>)</span>:</span></span><br><span class="line">       <span class="string">"read num bytes from serial port"</span></span><br><span class="line">       <span class="keyword">if</span> <span class="keyword">not</span> self.hComPort: <span class="keyword">raise</span> portNotOpenError</span><br><span class="line">       <span class="comment">#print "read %d" %size           ####debug</span></span><br><span class="line">       read = <span class="string">''</span></span><br><span class="line">       <span class="keyword">if</span> size &gt; <span class="number">0</span>:</span><br><span class="line">           <span class="keyword">while</span> len(read) &lt; size:</span><br><span class="line">               flags, comstat = win32file.ClearCommError( self.hComPort )</span><br><span class="line">               rc, buf = win32file.ReadFile(self.hComPort, size-len(read), self.overlapped)</span><br><span class="line">               <span class="keyword">if</span> self.timeout:</span><br><span class="line">                   rc = win32event.WaitForSingleObject(self.overlapped.hEvent, self.timeout*<span class="number">1000</span>)</span><br><span class="line">                   <span class="keyword">if</span> rc == win32event.WAIT_TIMEOUT: <span class="keyword">break</span></span><br><span class="line">                   <span class="comment">#<span class="doctag">TODO:</span> if reading more than 1 byte data can be lost when a timeout occours!!!!</span></span><br><span class="line">               <span class="keyword">else</span>:</span><br><span class="line">                   win32event.WaitForSingleObject(self.overlapped.hEvent, win32event.INFINITE)</span><br><span class="line">               read = read + str(buf)</span><br><span class="line">       <span class="comment">#print "read %r" % str(read)</span></span><br><span class="line">       <span class="keyword">return</span> str(read)</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>
                    <h2 id="pyserial1-21-read（）">
                      <a href="#pyserial1-21-read（）" class="headerlink" title="pyserial1.21    @read（）"></a>pyserial1.21 @read（）</h2>
                    <figure class="highlight python">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(self, size=<span class="number">1</span>)</span>:</span></span><br><span class="line">        <span class="string">"""read num bytes from serial port"""</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.hComPort: <span class="keyword">raise</span> portNotOpenError</span><br><span class="line">        <span class="keyword">if</span> size &gt; <span class="number">0</span>:</span><br><span class="line">            win32event.ResetEvent(self._overlappedRead.hEvent)</span><br><span class="line">            flags, comstat = win32file.ClearCommError(self.hComPort)</span><br><span class="line">            <span class="keyword">if</span> self.timeout == <span class="number">0</span>:</span><br><span class="line">                n = min(comstat.cbInQue, size)</span><br><span class="line">                <span class="keyword">if</span> n &gt; <span class="number">0</span>:</span><br><span class="line">                    rc, buf = win32file.ReadFile(self.hComPort, win32file.AllocateReadBuffer(n), self._overlappedRead)</span><br><span class="line">                    win32event.WaitForSingleObject(self._overlappedRead.hEvent, win32event.INFINITE)</span><br><span class="line">                    read = str(buf)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    read = <span class="string">''</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                rc, buf = win32file.ReadFile(self.hComPort, win32file.AllocateReadBuffer(size), self._overlappedRead)</span><br><span class="line">                n = win32file.GetOverlappedResult(self.hComPort, self._overlappedRead, <span class="number">1</span>)</span><br><span class="line">                read = str(buf[:n])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            read = <span class="string">''</span></span><br><span class="line">        <span class="keyword">return</span> read</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>
                    <p>总结起来是：最开始是采用每次读一个字符，轮训读来获取整串字符，典型的单片机式写法，1.21版本就主要围绕参数的检测开始写，首先保证你输入的参数是对的，以输入参数为中心来划分我函数内部的逻辑块，尤其注意:
                      <br>
                      <strong>pyserial1.1 :</strong>
                      <code>win32file.ReadFile(self.hComPort, size-len(read), self.overlapped)</code>
                      <br>
                      <strong>pyserial1.21:</strong>
                      <br>
                      <code>win32file.ReadFile(self.hComPort,</code>
                      <br>
                      <code>win32file.AllocateReadBuffer(n),</code>
                      <br>
                      <code>self._overlappedRead)</code>
                    </p>
                    <p>不同之处在于win32file.AllocateReadBuffer(n)：这是python下的一个标准化的分配缓冲的接口,在同步读文件的时候直接传一个int值就好了，但是异步读取模式就必须得用这个分配一块临时内存，具体原因请见我写的一篇解析感悟：
                      <a href="http://www.jianshu.com/p/9468803ae8b8">《Python Programming on Win32》中关于文件部分摘要及思考</a>。</p>
                    <figure class="highlight python">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line">PyOVERLAPPEDReadBuffer = AllocateReadBuffer(bufSize)</span><br><span class="line">Allocates a buffer which can be used <span class="keyword">with</span> an overlapped Read operation using win32file::ReadFile</span><br><span class="line">Parameters:</span><br><span class="line">       bufSize : int</span><br><span class="line">      The size of the buffer to allocate.</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>
                    <p>
                      <code>PyOVERLAPPEDReadBuffer Object</code>
                      <br>
                      <code>An alias for a standard Python buffer object. Previous versions
                        of the Windows extensions had a custom object for holding
                        a read buffer. This has been replaced with the standard Python
                        buffer object.Python does not provide a method for creating
                        a read-write buffer of arbitary size, so currently this can
                        only be created by win32file::AllocateReadBuffer.
                      </code>
                    </p>
                    <p>网上讨论当频繁调用.AllocateReadBuffer时会不会出现内存泄漏的情况：由于python的内存管理机制问题，当你的内存引用计数器为零时，内存会被自动回收，所以不存在内存泄漏问题。</p>
                    <figure class="highlight plain">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line">Spencer Ernest Doidge wrote:</span><br><span class="line">&gt; If I call win32file.AllocateReadBuffer(..) in a method that gets called</span><br><span class="line">&gt; repeatedly and terminates each time it is done, will I have a memory leak</span><br><span class="line">&gt; if I don&apos;t somehow free the allocated memory before concluding the run of</span><br><span class="line">&gt; the method? Or does the memory get de-allocated automagically when the</span><br><span class="line">&gt; method is finished running?</span><br><span class="line"></span><br><span class="line">Normal Python reference counting semantics apply - ie, when there are no </span><br><span class="line">references to the buffer it will be deleted.  Thus, there should be no </span><br><span class="line">leaks.</span><br><span class="line">Mark.</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>

                  </div>

                  <div>
                    <ul class="post-copyright">
                      <li class="post-copyright-author">
                        <strong>本文作者：</strong>
                        十曰立
                      </li>
                      <li class="post-copyright-link">
                        <strong>本文链接：</strong>
                        <a href="http://www.jianshu.com/u/a08f88f9ed9d/2017/11/16/四、pyserial1.x---read()write()演进/"
                                                                                                        title="四、pyserial1.x---read()/write()演进">http://www.jianshu.com/u/a08f88f9ed9d/2017/11/16/四、pyserial1.x---read()write()演进/</a>
                      </li>
                      <li class="post-copyright-license">
                        <strong>版权声明： </strong>
                        本博客所有文章除特别声明外，均采用
                        <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/"
                                                                                                        rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
                      </li>
                    </ul>

                  </div>

                  <div>

                    <div>

                      <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束
                        <i class="fa fa-paw"></i>感谢您的阅读-------------</div>

                    </div>

                  </div>
                  <footer class="post-footer">

                    <div class="post-nav">
                      <div class="post-nav-next post-nav-item">

                        <a href="/2017/11/13/第二周《卷积神经网络-实例探究》/" rel="next" title="第二周《卷积神经网络-实例探究》">
                          <i class="fa fa-chevron-left"></i> 第二周《卷积神经网络-实例探究》
                        </a>

                      </div>

                      <span class="post-nav-divider"></span>

                      <div class="post-nav-prev post-nav-item">

                        <a href="/2017/12/18/ARM平台底层NEON加速CNN 引入/" rel="prev" title="ARM平台底层NEON加速CNN 引入">
                          ARM平台底层NEON加速CNN 引入
                          <i class="fa fa-chevron-right"></i>
                        </a>

                      </div>
                    </div>

                  </footer>
                </div>

              </article>

              <div class="post-spread">

              </div>
            </div>

          </div>

        </div>

        <div class="sidebar-toggle">
          <div class="sidebar-toggle-line-wrap">
            <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
            <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
            <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
          </div>
        </div>

        <aside id="sidebar" class="sidebar">

          <div class="sidebar-inner">

            <ul class="sidebar-nav motion-element">
              <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
                文章目录
              </li>
              <li class="sidebar-nav-overview" data-target="site-overview-wrap">
                站点概览
              </li>
            </ul>

            <section class="site-overview-wrap sidebar-panel">
              <div class="site-overview">
                <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">

                  <img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="十曰立"
                  />

                  <p class="site-author-name" itemprop="name">十曰立</p>
                  <p class="site-description motion-element" itemprop="description">处在人工智能的洪流之中...</p>
                </div>

                <nav class="site-state motion-element">

                  <div class="site-state-item site-state-posts">

                    <a href="/archives">

                      <span class="site-state-item-count">13</span>
                      <span class="site-state-item-name">日志</span>
                    </a>
                  </div>

                  <div class="site-state-item site-state-categories">
                    <a href="/categories/index.html">
                      <span class="site-state-item-count">3</span>
                      <span class="site-state-item-name">分类</span>
                    </a>
                  </div>

                </nav>

                <div class="links-of-author motion-element">

                </div>

              </div>
            </section>

            <!--noindex-->
            <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
              <div class="post-toc">

                <div class="post-toc-content">
                  <ol class="nav">
                    <li class="nav-item nav-level-1">
                      <a class="nav-link" href="#write（）实现机理">
                        <span class="nav-number">1.</span>
                        <span class="nav-text">
                          write（）实现机理</span>
                      </a>
                      <ol class="nav-child">
                        <li class="nav-item nav-level-2">
                          <a class="nav-link" href="#1-1-win32file-CreateFile">
                            <span class="nav-number">1.1.</span>
                            <span class="nav-text">
                              1.1 win32file.CreateFile()</span>
                          </a>
                        </li>
                        <li class="nav-item nav-level-2">
                          <a class="nav-link" href="#1-2-win32file-OVERLAPPED">
                            <span class="nav-number">1.2.</span>
                            <span class="nav-text">
                              1.2 win32file.OVERLAPPED()</span>
                          </a>
                        </li>
                        <li class="nav-item nav-level-2">
                          <a class="nav-link" href="#1-3-win32event-CreateEvent">
                            <span class="nav-number">1.3.</span>
                            <span class="nav-text">
                              1.3 win32event.CreateEvent()</span>
                          </a>
                        </li>
                      </ol>
                    </li>
                    <li class="nav-item nav-level-1">
                      <a class="nav-link" href="#read-实现原理剖析">
                        <span class="nav-number">2.</span>
                        <span class="nav-text">
                          read() 实现原理剖析</span>
                      </a>
                      <ol class="nav-child">
                        <li class="nav-item nav-level-2">
                          <a class="nav-link" href="#pyserial1-1-read（）">
                            <span class="nav-number">2.1.</span>
                            <span class="nav-text">
                              pyserial1.1 @read（）</span>
                          </a>
                        </li>
                        <li class="nav-item nav-level-2">
                          <a class="nav-link" href="#pyserial1-21-read（）">
                            <span class="nav-number">2.2.</span>
                            <span class="nav-text">
                              pyserial1.21 @read（）</span>
                          </a>
                        </li>
                      </ol>
                    </li>
                  </ol>
                </div>

              </div>
            </section>
            <!--/noindex-->

          </div>
        </aside>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy;
          <span itemprop="copyrightYear">2017</span>
          <span class="with-love">
            <i class="fa fa-user"></i>
          </span>
          <span class="author" itemprop="copyrightHolder">十曰立</span>

          <span class="post-meta-divider">|</span>
          <span class="post-meta-item-icon">
            <i class="fa fa-area-chart"></i>
          </span>

          <span class="post-meta-item-text">Site words total count&#58;</span>

          <span title="Site words total count">43.1k</span>

        </div>

        <div class="powered-by">footer.powered</div>

        <span class="post-meta-divider">|</span>

        <div class="theme-info">footer.theme &mdash;
          <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>

      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>

    </div>

  </div>

  <script type="text/javascript">
    if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
      window.Promise = null;
    }

  </script>

  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>

  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
  <script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>

  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>

  <script>
    (function() {
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      } else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();

  </script>

</body>

</html>
